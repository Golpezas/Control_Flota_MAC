from fastapi import APIRouter, HTTPException, Query, status, Response
from typing import List, Optional
from datetime import datetime
import math
from bson.objectid import ObjectId

# Importaciones desde el m√≥dulo de dependencias
from dependencies import (
    get_db_collection, safe_mongo_date_to_datetime, VENCIMIENTO_MAP, 
    Alerta, Vehiculo, VehiculoUpdate, 
    # NUEVAS DEPENDENCIAS PARA FINANZAS
    CostoItem, ReporteCostosResponse, normalize_patente, sort_costo_by_date,
    CostoManualInput # üîë Aseg√∫rate de que esta l√≠nea est√© presente
)

# Define el router de FastAPI
# CORRECCI√ìN CLAVE: Eliminamos el tag principal para evitar la duplicaci√≥n.
router = APIRouter(
    prefix="",
)

# =========================================================================
# 1. L√ìGICA CORE: OBTENER VENCIMIENTOS CR√çTICOS (Mantenida)
# =========================================================================

def get_vencimientos_criticos_alertas(dias_tolerancia: int) -> List[Alerta]:
    """Genera alertas de vencimientos de documentaci√≥n basados en la tolerancia."""
    
    db_documentacion = get_db_collection("Documentacion")
    db_vehiculos = get_db_collection("Vehiculos")
    
    vehiculos_map = {
        v['_id']: {'nro_movil': v.get('NRO_MOVIL', 'N/A'), 'modelo': v.get('MODELO', 'N/A')} 
        for v in db_vehiculos.find({})
    }
    
    hoy = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    alertas: List[Alerta] = []
    documentos = list(db_documentacion.find({}))
    
    documentos_saltados = 0
    fallos_parseo = 0

    for doc in documentos:
        patente = doc.get('patente')
        tipo_documento_db = doc.get('tipo_documento', 'Desconocido')
        tipo_documento_legible = VENCIMIENTO_MAP.get(tipo_documento_db, tipo_documento_db)
        fecha_vencimiento_raw = doc.get('fecha_vencimiento') 
        fecha_vencimiento = safe_mongo_date_to_datetime(fecha_vencimiento_raw)
        
        if not fecha_vencimiento:
            if fecha_vencimiento_raw is None or (isinstance(fecha_vencimiento_raw, float) and math.isnan(fecha_vencimiento_raw)):
                documentos_saltados += 1
                continue
            else:
                fallos_parseo += 1
                documentos_saltados += 1
                continue
        
        dias_restantes = (fecha_vencimiento - hoy).days
        
        if dias_restantes <= dias_tolerancia:
            prioridad = "CR√çTICA" if dias_restantes <= 0 else "ALTA"
            mensaje = f"VENCIDO hace {-dias_restantes} d√≠as." if dias_restantes <= 0 else f"Vence en {dias_restantes} d√≠as."
            
            info_vehiculo = vehiculos_map.get(patente, {})

            alertas.append(Alerta(
                patente=patente,
                tipo_documento=tipo_documento_legible, 
                fecha_vencimiento=fecha_vencimiento.strftime('%Y-%m-%d'), 
                dias_restantes=dias_restantes,
                mensaje=mensaje,
                prioridad=prioridad,
                movil_nro=info_vehiculo.get('nro_movil'),
                descripcion_modelo=info_vehiculo.get('modelo')
            ))
            
    return alertas

# =========================================================================
# 2. ENDPOINT DE ALERTAS (Etiqueta √önica)
# =========================================================================

@router.get(
    "/alertas/vencimientos_criticos", 
    response_model=List[Alerta],
    summary="Obtener alertas de vencimiento de documentaci√≥n",
    tags=["Alertas y Reportes"] # Etiqueta espec√≠fica para este endpoint
)
async def get_alertas_vencimientos(
    dias_tolerancia: int = Query(60, description="D√≠as de anticipaci√≥n para considerar una alerta cr√≠tica.")
):
    try:
        alertas = get_vencimientos_criticos_alertas(dias_tolerancia)
        return alertas
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error interno al procesar alertas: {e}")

# =========================================================================
# 3. GESTI√ìN CRUD COMPLETA DE VEH√çCULOS (Etiquetas √önicas)
# =========================================================================

@router.post(
    "/vehiculos",
    response_model=Vehiculo,
    status_code=status.HTTP_201_CREATED,
    summary="Crear un nuevo veh√≠culo",
    tags=["Veh√≠culos"] # Etiqueta espec√≠fica para este endpoint
)
async def create_vehiculo(vehiculo_data: Vehiculo):
    """Registra un nuevo veh√≠culo en la colecci√≥n 'Vehiculos' usando la patente como ID."""
    db_vehiculos = get_db_collection("Vehiculos")
    
    doc_to_insert = vehiculo_data.model_dump(by_alias=True, exclude_unset=True)
    patente_id = doc_to_insert.pop('patente')
    doc_to_insert['_id'] = patente_id.upper() 

    if db_vehiculos.find_one({"_id": doc_to_insert['_id']}):
        raise HTTPException(status_code=400, detail=f"El veh√≠culo con patente {patente_id} ya existe.")
    
    db_vehiculos.insert_one(doc_to_insert)
    
    # Asegurarse de que el objeto retornado tenga la patente capitalizada si la DB lo usa as√≠
    vehiculo_data.patente = doc_to_insert['_id']
    return vehiculo_data


@router.get(
    "/vehiculos",
    response_model=List[Vehiculo],
    summary="Listar todos los veh√≠culos de la flota",
    tags=["Veh√≠culos"] # Etiqueta espec√≠fica para este endpoint
)
async def get_all_vehiculos():
    """Retorna la lista completa de veh√≠culos, mapeando el ID de MongoDB a 'patente'."""
    db_vehiculos = get_db_collection("Vehiculos")
    vehiculos = list(db_vehiculos.find({})) 
    
    result = []
    for v in vehiculos:
        # Renombrar _id a patente para el modelo Pydantic
        v['patente'] = v.pop('_id', None) 
        result.append(Vehiculo(**v))
        
    return result

@router.get(
    "/vehiculos/{patente}",
    response_model=Vehiculo,
    summary="Buscar un veh√≠culo por Patente",
    tags=["Veh√≠culos"] # Etiqueta espec√≠fica para este endpoint
)
async def get_vehiculo_by_patente(patente: str):
    """Busca y retorna la informaci√≥n de un veh√≠culo usando su Patente como ID."""
    db_vehiculos = get_db_collection("Vehiculos")
    vehiculo_doc = db_vehiculos.find_one({"_id": patente.upper()})
    
    if not vehiculo_doc:
        raise HTTPException(status_code=404, detail=f"Veh√≠culo con patente {patente} no encontrado.")
    
    vehiculo_doc['patente'] = vehiculo_doc.pop('_id', None)
    
    return Vehiculo(**vehiculo_doc)


@router.put(
    "/vehiculos/{patente}",
    response_model=Vehiculo,
    summary="Actualizar la informaci√≥n completa de un veh√≠culo",
    tags=["Veh√≠culos"] # Etiqueta espec√≠fica para este endpoint
)
async def update_vehiculo(patente: str, vehiculo_data: VehiculoUpdate):
    """Actualiza los campos proporcionados para un veh√≠culo espec√≠fico."""
    db_vehiculos = get_db_collection("Vehiculos")
    
    update_data = vehiculo_data.model_dump(by_alias=True, exclude_unset=True)
    
    update_result = db_vehiculos.update_one(
        {"_id": patente.upper()},
        {"$set": update_data}
    )

    if update_result.matched_count == 0:
        raise HTTPException(status_code=404, detail=f"Veh√≠culo con patente {patente} no encontrado para actualizar.")
    
    updated_doc = db_vehiculos.find_one({"_id": patente.upper()})
    if updated_doc:
        updated_doc['patente'] = updated_doc.pop('_id', None)
        return Vehiculo(**updated_doc)
    
    raise HTTPException(status_code=500, detail="Error interno al recuperar el documento actualizado.")


# =========================================================================
# 5. ENDPOINT: ELIMINAR VEH√çCULO (DELETE /vehiculos/{patente})
# =========================================================================
@router.delete(
    "/vehiculos/{patente}",
    status_code=status.HTTP_204_NO_CONTENT,
    tags=["Vehiculos"],
    summary="Elimina un veh√≠culo por su patente normalizada (ID).",
    response_model=None,
)
def delete_vehiculo(patente: str, response: Response):
    """
    Elimina un veh√≠culo de la colecci√≥n 'Vehiculos' por su ID (patente normalizada).
    """
    # 1. Normalizar la patente para asegurar la coincidencia con el _id
    patente_normalized = normalize_patente(patente)
    
    db_vehiculos = get_db_collection("Vehiculos")

    # 2. Eliminar el documento
    delete_result = db_vehiculos.delete_one({"_id": patente_normalized})

    if delete_result.deleted_count == 0:
        raise HTTPException(
            status_code=404, 
            detail=f"Veh√≠culo no encontrado con patente/ID: {patente_normalized}."
        )

    # Si es exitoso, devuelve 204 No Content
    response.status_code = status.HTTP_204_NO_CONTENT
    return

# =========================================================================
# 4. ENDPOINT: REPORTE DE COSTOS FINANCIEROS (ETAPA 6)
# =========================================================================

@router.get("/vehiculos/{patente}/costos_financieros", response_model=ReporteCostosResponse, tags=["ETAPA 6: FINANZAS"])
async def get_costos_financieros(patente: str):
    """
    [ETAPA 6: FINANZAS] Retorna un reporte consolidado de todos los costos (multas, 
    mantenimiento y servicios) asociados a un veh√≠culo.
    """
    # Usamos la funci√≥n auxiliar 'normalize_patente' (ahora importada desde dependencies)
    patente_id = normalize_patente(patente) 
    
    # Obtenemos las colecciones usando la funci√≥n auxiliar 'get_db_collection' 
    col_vehiculos = get_db_collection('Vehiculos')
    col_finanzas = get_db_collection('Finanzas')
    col_mantenimiento = get_db_collection('Mantenimiento')
    
    # 1. Verificar si el veh√≠culo existe
    # NOTA: Usamos el campo '_id' para la b√∫squeda, asumiendo que 'normalize_patente' lo usa.
    if not col_vehiculos.find_one({"_id": patente_id}, projection={'_id': 1}):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Veh√≠culo con patente '{patente}' no encontrado.")
        
    all_costs: List[CostoItem] = []
    total_mantenimiento = 0.0
    total_infracciones = 0.0

    # --- A. Procesar Costos de Mantenimiento (Servicios y Reparaciones) ---
    mantenimiento_cursor = col_mantenimiento.find({"patente": patente_id})
    for doc in mantenimiento_cursor:
        
        # 1. TRATAR IMPORTE
        importe = doc.get('costo_monto')
        # Verificar si es None, o si es un float NaN
        if importe is None or (isinstance(importe, float) and math.isnan(importe)):
            importe = 0.0 
        
        # 2. TRATAR KILOMETRAJE (metadata)
        km_value = doc.get('kilometraje_km')
        if km_value is None or (isinstance(km_value, float) and math.isnan(km_value)):
            km_value = None 
            
        # Usamos 'motivo' para determinar el tipo (SERVICIO o REPARACI√ìN)
        motivo_str = str(doc.get('motivo', ''))
            
        # Determinar el tipo de costo de mantenimiento
        tipo_costo_mantenimiento = "Reparaci√≥n"
        if motivo_str.lower().startswith(('servicio', 'service')):
             tipo_costo_mantenimiento = "Servicio"
            
        total_mantenimiento += importe
        
        # Crear CostoItem
        all_costs.append(CostoItem(
            tipo=tipo_costo_mantenimiento,
            fecha=str(doc.get('fecha')),
            descripcion=str(doc.get('DESCRIPCIN', 'Sin detalle')),
            importe=importe,
            origen="Mantenimiento",
            metadata_adicional={
                "nro_movil": doc.get('MOVIL_N'),
                "km": km_value
            }
        ))
        
    # --- B. Procesar Costos de Finanzas (Infracciones/Multas) ---
    finanzas_cursor = col_finanzas.find({"patente": patente_id})
    for doc in finanzas_cursor:
        
        # 1. TRATAR IMPORTE
        importe = doc.get('monto')
        # Verificar si es None, o si es un float NaN
        if importe is None or (isinstance(importe, float) and math.isnan(importe)):
            importe = 0.0
            
        total_infracciones += importe
        
        # Determinar el tipo
        tipo_costo_finanzas = "Multa/Infracci√≥n"
        if "Seguro" in str(doc.get('ACTA')):
             tipo_costo_finanzas = "Gasto Seguro"
             
        # Crear CostoItem
        all_costs.append(CostoItem(
            tipo=tipo_costo_finanzas,
            fecha=str(doc.get('dia', doc.get('HASTA'))),
            descripcion=str(doc.get('motivo', 'Infracci√≥n no detallada')),
            importe=importe,
            origen="Finanzas",
            metadata_adicional={
                "nro_acta": doc.get('ACTA'),
                "lugar": doc.get('lugar')
            }
        ))
        
    # -------------------------------------------------------------
    # üí• PASO DE LIMPIEZA: FILTRAR ITEMS CON IMPORTE CERO (0) üí•
    # -------------------------------------------------------------
    # Esto elimina los registros que, despu√©s de la limpieza NaN, tienen importe $0.
    all_costs = [costo for costo in all_costs if costo.importe > 0] 

    total_general = total_mantenimiento + total_infracciones

    # Ordenamos de m√°s reciente a m√°s antiguo usando la funci√≥n auxiliar 'sort_costo_by_date' 
    # (ahora importada desde dependencies)
    all_costs.sort(key=sort_costo_by_date, reverse=True)

    # Retornar el reporte consolidado
    return ReporteCostosResponse(
        patente=patente_id,
        total_costos_mantenimiento=round(total_mantenimiento, 2),
        total_costos_infracciones=round(total_infracciones, 2),
        total_general=round(total_general, 2),
        detalles=all_costs
    )

# =========================================================================
# 4. NUEVOS ENDPOINTS: CREACI√ìN MANUAL DE COSTOS (Fase 2)
# =========================================================================

@router.post(
    "/costos/crear",
    tags=["Costos"],
    summary="Permite al usuario registrar manualmente un gasto (multa, reparaci√≥n, etc.)",
    status_code=status.HTTP_201_CREATED
)
def create_costo_manual(data: CostoManualInput):
    """
    Registra un nuevo item de costo/gasto en la colecci√≥n de 'Finanzas' o 'Mantenimiento'.
    La patente debe existir en la colecci√≥n 'Vehiculos'.
    """
    
    # 1. Normalizar la patente y verificar existencia del veh√≠culo
    patente_normalized = normalize_patente(data.patente)
    vehiculos_collection = get_db_collection("Vehiculos")
    if vehiculos_collection.find_one({"_id": patente_normalized}) is None:
        raise HTTPException(status_code=404, detail=f"Veh√≠culo con patente '{data.patente}' no encontrado. No se puede asignar un costo.")
        
    # 2. Determinar la colecci√≥n de destino
    # El campo 'origen' viene del Pydantic CostoManualInput y ya est√° validado (Finanzas o Mantenimiento).
    collection_name = data.origen 
    collection = get_db_collection(collection_name)

    # 3. Mapear los datos de entrada al formato de la DB
    # Nota: Adaptamos los nombres de campo para ser consistentes con la estructura de tu ETL (MONTO vs costo_monto).
    fecha_iso = data.fecha.isoformat()
    
    document_to_insert = {
        "patente_id": patente_normalized, 
        "origen_manual": True,            
        "tipo_registro": data.tipo_costo,  

        # Nombres de campos basados en tu ETL
        "MONTO" if collection_name == 'Finanzas' else "costo_monto": data.importe,
        "motivo" if collection_name == 'Finanzas' else "descripcion_manual": data.descripcion,
        
        # Nombres de campos de fecha
        "dia" if collection_name == 'Finanzas' else "fecha_costo": fecha_iso,
        "fecha_creacion_api": datetime.now().isoformat(),
    }
    
    # 4. Inserci√≥n en la DB
    try:
        result = collection.insert_one(document_to_insert)
        
        # 5. Respuesta
        return {
            "status": "success",
            "message": f"Costo manual de tipo '{data.tipo_costo}' registrado con √©xito.",
            "document_id": str(result.inserted_id)
        }
    except Exception as e:
        print(f"Error al insertar costo manual: {e}")
        # Retorna un error 500 si MongoDB falla
        raise HTTPException(status_code=500, detail=f"Error interno del servidor al guardar el costo: {str(e)}")

# =========================================================================
# 6. ENDPOINT: ALERTAS GLOBALES (Nuevo para Dashboard)
# =========================================================================
@router.get(
    "/alertas/criticas",
    response_model=List[Alerta],
    tags=["Alertas"],
    summary="Obtiene todas las alertas cr√≠ticas (vencimiento < 30 d√≠as o expiradas) de la flota.",
)
def get_global_criticas():
    """
    Recupera todas las alertas cr√≠ticas de documentaci√≥n de la flota, limitadas a 30 d√≠as.
    """
    try:
        # Usamos una tolerancia de 30 d√≠as como est√°ndar para alertas cr√≠ticas
        alertas = get_vencimientos_criticos_alertas(dias_tolerancia=30)
        return alertas
    except Exception as e:
        print(f"‚ùå Error al obtener alertas globales: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
                            detail=f"Fallo del servidor al procesar alertas: {e}")
    
# =========================================================================
# 7. ENDPOINT: ELIMINAR COSTO/GASTO (Nuevo)
# =========================================================================

@router.delete(
    "/costos/{origen}/{document_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    tags=["Costos"],
    summary="Elimina un √≠tem de costo/gasto por su ID y colecci√≥n de origen.",
    # No retorna contenido si es exitoso (204 No Content)
    response_model=None,
)
def delete_costo_item(origen: str, document_id: str, response: Response):
    """
    Elimina un documento de costo de las colecciones 'Finanzas' o 'Mantenimiento'.
    """
    if origen not in ["Finanzas", "Mantenimiento"]:
        raise HTTPException(
            status_code=400,
            detail="Origen de costo no v√°lido. Debe ser 'Finanzas' o 'Mantenimiento'."
        )

    try:
        obj_id = ObjectId(document_id)
    except Exception:
        raise HTTPException(
            status_code=400,
            detail="ID de documento no v√°lido. Aseg√∫rese de usar un ObjectId v√°lido (24 caracteres hexadecimales)."
        )

    collection = get_db_collection(origen)

    # Buscar y eliminar por ID
    delete_result = collection.delete_one({"_id": obj_id})

    if delete_result.deleted_count == 0:
        raise HTTPException(
            status_code=404, 
            detail=f"Costo no encontrado con ID {document_id} en la colecci√≥n {origen}."
        )

    # Si es exitoso, devuelve 204 No Content
    response.status_code = status.HTTP_204_NO_CONTENT
    return

# =========================================================================
# 4. ENDPOINT DASHBOARD (Consolidaci√≥n)
# =========================================================================

@router.get(
    "/dashboard/resumen",
    response_model=DashboardResponse, # Usa el nuevo modelo
    tags=["General - Dashboard"]
)
async def get_dashboard_resumen():
    """Retorna un resumen global de costos y alertas cr√≠ticas para el Dashboard."""
    
    # --- 1. Obtener Alertas Cr√≠ticas (Reutilizando l√≥gica existente) ---
    # Asumimos que quieres alertas con menos de 30 d√≠as de tolerancia por defecto
    alertas = get_vencimientos_criticos_alertas(dias_tolerancia=30) 
    
    # --- 2. Calcular Resumen de Costos Globales ---
    db_finanzas = get_db_collection("Finanzas")
    db_mantenimiento = get_db_collection("Mantenimiento")
    db_vehiculos = get_db_collection("Vehiculos")

    # Mantenimiento: Suma del campo 'costo_monto'
    pipeline_mantenimiento = [{ "$group": { "_id": None, "total": { "$sum": "$costo_monto" } } }]
    resumen_mant = list(db_mantenimiento.aggregate(pipeline_mantenimiento))
    total_mantenimiento = resumen_mant[0]["total"] if resumen_mant else 0.0

    # Infracciones: Suma del campo 'MONTO' donde 'tipo_registro' es 'Infraccion'
    pipeline_infracciones = [
        { "$match": { "tipo_registro": "Infraccion" } },
        { "$group": { "_id": None, "total": { "$sum": "$MONTO" } } }
    ]
    resumen_infr = list(db_finanzas.aggregate(pipeline_infracciones))
    total_infracciones = resumen_infr[0]["total"] if resumen_infr else 0.0
    
    # Conteo total de veh√≠culos
    total_vehiculos = db_vehiculos.count_documents({})
    
    resumen_costos = {
        "total_mantenimiento": total_mantenimiento,
        "total_infracciones": total_infracciones,
        "total_general": total_mantenimiento + total_infracciones,
    }

    # --- 3. Retornar la respuesta consolidada ---
    return {
        "alertas_criticas": alertas,
        "resumen_costos": resumen_costos,
        "total_vehiculos": total_vehiculos,
    }

# =========================================================================
# 5. ENDPOINT REPORTE DE COSTOS POR RANGO DE FECHA (NUEVO)
# =========================================================================

@router.get(
    "/reportes/costos",
    response_model=ReportePeriodoResponse,
    tags=["Reportes"]
)
async def get_reporte_costos_periodo(
    fecha_inicio: str = Query(..., description="Fecha de inicio del periodo (YYYY-MM-DD)"),
    fecha_fin: str = Query(..., description="Fecha de fin del periodo (YYYY-MM-DD)")
):
    """
    Retorna un resumen agregado de costos de Mantenimiento e Infracciones
    dentro de un rango de fechas.
    """
    try:
        # 1. Parsear las fechas de entrada y ajustarlas para el rango
        start_date_dt = datetime.strptime(fecha_inicio, '%Y-%m-%d')
        # La fecha fin debe incluir todo el d√≠a, por lo que se ajusta a medianoche (23:59:59)
        end_date_dt = datetime.strptime(fecha_fin, '%Y-%m-%d').replace(hour=23, minute=59, second=59)

        if start_date_dt >= end_date_dt:
             raise HTTPException(status_code=400, detail="La fecha de inicio debe ser anterior a la fecha de fin.")

        # Convertir a ISO string para la consulta de MongoDB
        start_date_iso = start_date_dt.isoformat()
        end_date_iso = end_date_dt.isoformat()

    except ValueError:
        raise HTTPException(status_code=400, detail="Formato de fecha inv√°lido. Use YYYY-MM-DD.")


    # --- 2. Consultar Mantenimiento ---
    db_mantenimiento = get_db_collection("Mantenimiento")
    # El campo de fecha en Mantenimiento es 'fecha_costo'
    pipeline_mantenimiento = [
        {
            "$match": {
                "fecha_costo": {
                    "$gte": start_date_iso, # Usamos el string ISO generado
                    "$lte": end_date_iso
                }
            }
        },
        { "$group": { "_id": None, "total": { "$sum": "$costo_monto" } } }
    ]
    
    try:
        resumen_mant_result = list(db_mantenimiento.aggregate(pipeline_mantenimiento))
        total_mantenimiento = resumen_mant_result[0]["total"] if resumen_mant_result and resumen_mant_result[0].get("total") is not None else 0.0
    except Exception:
        total_mantenimiento = 0.0

    # --- 3. Consultar Finanzas (Infracciones) ---
    db_finanzas = get_db_collection("Finanzas")
    # El campo de fecha en Finanzas es 'dia'
    pipeline_infracciones = [
        { 
            "$match": { 
                "tipo_registro": "Infraccion",
                "dia": {
                    "$gte": start_date_iso, # Usamos el string ISO generado
                    "$lte": end_date_iso
                }
            }
        },
        { "$group": { "_id": None, "total": { "$sum": "$MONTO" } } }
    ]
    try:
        resumen_infr_result = list(db_finanzas.aggregate(pipeline_infracciones))
        total_infracciones = resumen_infr_result[0]["total"] if resumen_infr_result and resumen_infr_result[0].get("total") is not None else 0.0
    except Exception:
        total_infracciones = 0.0
    
    # --- 4. Consolidar Resultados ---
    total_general = total_mantenimiento + total_infracciones
    
    datos_agregados = [
        {"categoria": "Mantenimiento", "total": round(total_mantenimiento, 2)},
        {"categoria": "Infracciones", "total": round(total_infracciones, 2)}
    ]

    return ReportePeriodoResponse(
        fecha_inicio=fecha_inicio,
        fecha_fin=fecha_fin,
        datos_agregados=datos_agregados,
        total_general=round(total_general, 2),
        total_mantenimiento=round(total_mantenimiento, 2),
        total_infracciones=round(total_infracciones, 2),
    )